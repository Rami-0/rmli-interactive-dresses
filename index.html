<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.5D Parallax Fashion Gallery</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            overflow: hidden; /* Prevent default body scrolling */
        }
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #scene-container:active {
            cursor: grabbing;
        }

        /* Info Modal Styles */
        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            z-index: 1000;
        }
        #modal.visible {
            opacity: 1;
            visibility: visible;
        }
        /* Style for right-to-left Arabic text */
        [dir="rtl"] {
            direction: rtl;
        }

        /* Scrollbar Styles */
        #scrollbar-container {
            position: fixed;
            bottom: 30px;
            left: 10%;
            width: 80%;
            height: 6px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
            z-index: 100;
            cursor: pointer;
        }
        #scrollbar-thumb {
            position: absolute;
            top: -5px; /* Vertically center */
            left: 0;
            width: 15%; /* Width of the thumb */
            height: 16px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #scrollbar-thumb:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- This canvas is where the three.js scene will be rendered -->
    <div id="scene-container"></div>

    <!-- Scrollbar -->
    <div id="scrollbar-container">
        <div id="scrollbar-thumb"></div>
    </div>

    <!-- 
      Info Modal 
      This is hidden by default and will be populated and shown by JavaScript.
    -->
    <div id="modal">
        <div id="modal-content" class="bg-white w-11/12 max-w-4xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col md:flex-row overflow-hidden transform scale-95 transition-transform duration-400">
            <!-- Close Button -->
            <button id="modal-close-btn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-800 z-10">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            
            <!-- Image Side -->
            <div class="w-full md:w-1/2 h-64 md:h-auto overflow-hidden">
                <img id="modal-image" src="" alt="Fashion item" class="w-full h-full object-contain p-4 md:p-8">
            </div>

            <!-- Content Side (with Arabic text example) -->
            <div dir="rtl" class="w-full md:w-1/2 p-8 md:p-12 overflow-y-auto">
                <h2 id="modal-title" class="text-4xl font-bold text-gray-900 mb-6"></h2>
                
                <div class="space-y-6 text-gray-700 text-lg">
                    <div class="border-b pb-4">
                        <p class="font-semibold text-gray-500 mb-2">ينتمي هذا الزي لمنطقة</p>
                        <p id="modal-region" class="text-2xl font-semibold"></p>
                    </div>

                    <div class="border-b pb-4">
                        <p class="font-semibold text-gray-500 mb-3">أنواع الأقمشة</p>
                        <div id="modal-fabrics" class="flex flex-wrap gap-3">
                            <!-- Fabric tags will be inserted here -->
                        </div>
                    </div>
                    
                    <div>
                        <p class="font-semibold text-gray-500 mb-3">الوصف</p>
                        <p id="modal-description" class="leading-relaxed"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, backgroundCylinder, controls;
        const characters = []; // To store character planes
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        // --- DATA for characters and modal ---
        // TODO: Replace placeholders with your actual asset URLs
        const characterData = [
            {
                id: 1,
                name: "فستان سفرة سعود",
                region: "الرياض (نجد)",
                fabrics: ["القطن", "الحرير"],
                description: "يتميز الزي النجدي التقليدي النسائي بفرادة تعكس روح الصحراء وأناقة المرأة في قلب الجزيرة. كانت المرأة النجدية ترتدي أثوابًا فضفاضة تُسمّى الثوب، تخاط عادةً من الأقمشة الخفيفة كالقطن والحرير، وتتزين بخيوط مذهبة أو ملونة.",
                // TODO: Replace with your actual character image
                image: "https://placehold.co/400x1200/FFFFFF/333333?text=Character+1&transparent=true" 
            },
            {
                id: 2,
                name: "الثوب المرودن",
                region: "المنطقة الوسطى",
                fabrics: ["الحرير", "الزري"],
                description: "ومن أشهر هذه الأثواب المرودن ذو الأكمام الطويلة الواسعة، والدقلة النسائية التي تستخدم للمناسبات.",
                // TODO: Replace with your actual character image
                image: "https://placehold.co/400x1200/FFFFFF/333333?text=Character+2&transparent=true"
            },
            {
                id: 3,
                name: "فستان الزري",
                region: "المنطقة الشرقية",
                fabrics: ["القطن"],
                description: "تطرز يدويا بخيوط «الزري» أو «القصة» وتمنح الثوب لمسة فاخرة وطابعا سعوديا أصيلا يستمر حتى اليوم في التصاميم الحديثة.",
                // TODO: Replace with your actual character image
                image: "https://placehold.co/400x1200/FFFFFF/333333?text=Character+3&transparent=true"
            },
            {
                id: 4,
                name: "الدقلة النسائية",
                region: "نجد",
                fabrics: ["الحرير"],
                description: "تتميز بزخارف هندسية دقيقة تجمع بين خطوط مستقيمة ونقاط متكررة، تُطرّز بخيوط معدنية غالبا ما تكون ذهبية أو بلون نحاسي.",
                // TODO: Replace with your actual character image
                image: "https://placehold.co/400x1200/FFFFFF/333333?text=Character+4&transparent=true"
            },
            {
                id: 5,
                name: "ثوب المناسبات",
                region: "الرياض",
                fabrics: ["القطن", "الذهب"],
                description: "أما الزخارف النجدية عموما فتعتمد على التكرار الهندسي والرموز المستواحاة من البيئة، مثل المثلثات النجوم، الأشرطة المتوازية.",
                // TODO: Replace with your actual character image
                image: "https://placehold.co/400x1200/FFFFFF/333333?text=Character+5&transparent=true"
            }
        ];

        // --- Scene rotation variables ---
        let isDragging = false;
        let pointerDownX = 0;
        let pointerDownY = 0;
        let previousPointerX = 0;
        let hasDragged = false; // Track if user actually dragged (not just clicked)
        let dragThreshold = 5; // Pixels to move before considering it a drag
        let isThumbDragging = false; // For scrollbar
        let previousThumbX = 0; // For scrollbar
        let rotationTarget = 0; // Target rotation (in radians)
        let rotationCurrent = 0; // Current camera rig rotation
        const rotationSpeed = 0.005; // Speed for drag rotation
        const lerpFactor = 0.05; // Smoothing factor for animation
        const characterFocusScale = 1.2; // How much to scale active character
        const baseCharacterScale = 1; // Base scale

        // --- REMOVED Snap variables ---

        // --- Main container for camera and characters ---
        // We rotate this group instead of the camera directly
        const cameraRig = new THREE.Group();
        let characterGroup; // NEW: Group for characters

        function init() {
            const container = document.getElementById('scene-container');

            // --- Scene ---
            scene = new THREE.Scene();

            // --- Camera ---
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000); // CHANGED: FOV from 70 to 80
            camera.position.z = 0; // CHANGED: Camera is AT the center
            cameraRig.add(camera); // Add camera to the rig
            scene.add(cameraRig); // Add the rig to the scene

            // NEW: Create a separate group for characters
            characterGroup = new THREE.Group();
            scene.add(characterGroup);

            // --- Renderer ---
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);

            // --- Load Textures ---
            const textureLoader = new THREE.TextureLoader();

            // --- 1. Create Background Cylinder ---
            // TODO: Replace with your panoramic background image URL
            const backgroundTextureUrl = "https://placehold.co/4096x1024/E0D6C3/5C4033?text=Panoramic+Desert+Background+Scene+(4096x1024)";
            const bgTexture = textureLoader.load(backgroundTextureUrl);
            // Ensure texture repeats horizontally if the user scrolls far
            bgTexture.wrapS = THREE.RepeatWrapping; 
            
            // A large cylinder. We are inside it.
            const bgGeometry = new THREE.CylinderGeometry(50, 50, 50, 64, 1, true); 
            // Map the texture to the *inside* of the cylinder
            const bgMaterial = new THREE.MeshBasicMaterial({ 
                map: bgTexture, 
                side: THREE.BackSide 
            });
            backgroundCylinder = new THREE.Mesh(bgGeometry, bgMaterial);
            backgroundCylinder.rotation.y = Math.PI / 2; // Adjust alignment
            scene.add(backgroundCylinder);

            // --- 2. Create Character Planes ---
            const totalCharacters = characterData.length;
            const angleStep = (Math.PI * 2) / totalCharacters; // Angle between each character
            const characterRadius = 15; // How far characters are from center
            const characterHeight = 10; // Vertical size of the plane

            characterData.forEach((data, i) => {
                const charTexture = textureLoader.load(data.image);
                // Aspect ratio for the plane
                const charAspect = 400 / 1200; // Based on placeholder size
                const charGeometry = new THREE.PlaneGeometry(characterHeight * charAspect, characterHeight);
                const charMaterial = new THREE.MeshBasicMaterial({
                    map: charTexture,
                    transparent: true,
                    side: THREE.DoubleSide // RE-ADDED: Make it double-sided again
                });

                const characterPlane = new THREE.Mesh(charGeometry, charMaterial);

                // Position characters in a circle
                const angle = angleStep * i - (Math.PI / 2); // Start at the front
                characterPlane.position.x = Math.cos(angle) * characterRadius;
                characterPlane.position.z = Math.sin(angle) * characterRadius;
                
                // REVERTED: Make character face the center (0,0,0)
                characterPlane.lookAt(0, 0, 0);

                // Store data for click interaction
                characterPlane.userData = data; 

                characters.push(characterPlane);
                characterGroup.add(characterPlane); // CHANGED: Add characters to their own group
            });

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
            container.addEventListener('wheel', onWheelScroll, { passive: false });
            container.addEventListener('pointerdown', onPointerDown, false);
            // CHANGED: Listen on document to catch moves/ups everywhere
            document.addEventListener('pointermove', onDocumentPointerMove, false);
            document.addEventListener('pointerup', onDocumentPointerUp, false);
            container.addEventListener('click', onClick, false);

            // NEW: Scrollbar listeners
            document.getElementById('scrollbar-thumb').addEventListener('pointerdown', onThumbPointerDown, false);

            // Modal close button
            document.getElementById('modal-close-btn').addEventListener('click', hideModal);

            // --- Start Animation Loop ---
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Interaction Handlers ---

        function onWheelScroll(event) {
            event.preventDefault();

            // Adjust rotation target based on horizontal scroll
            const scrollDelta = event.deltaY || event.deltaX;
            rotationTarget += scrollDelta * 0.001;
        }

        function onPointerDown(event) {
            isDragging = true;
            hasDragged = false;
            pointerDownX = event.clientX;
            pointerDownY = event.clientY;
            previousPointerX = event.clientX;
            document.getElementById('scene-container').style.cursor = 'grabbing';
        }

        // NEW: Handles scrollbar thumb dragging
        function onThumbPointerDown(event) {
            event.stopPropagation(); // Prevent scene drag
            
            isThumbDragging = true;
            previousThumbX = event.clientX;
            document.getElementById('scrollbar-thumb').style.cursor = 'grabbing';
            document.body.style.cursor = 'grabbing';
        }

        // CHANGED: Renamed from onPointerMove and now handles both scene and thumb dragging
        function onDocumentPointerMove(event) {
            if (isDragging) {
                // Check if user has moved enough to be considered dragging
                const distance = Math.sqrt(
                    Math.pow(event.clientX - pointerDownX, 2) + 
                    Math.pow(event.clientY - pointerDownY, 2)
                );
                
                // Only apply rotation and mark as dragged if movement exceeds threshold
                if (distance > dragThreshold) {
                    hasDragged = true;
                    const deltaX = event.clientX - previousPointerX;
                    rotationTarget -= deltaX * rotationSpeed;
                }
                // Always update previousPointerX to track position accurately
                previousPointerX = event.clientX;
            }

            if (isThumbDragging) {
                const deltaX = event.clientX - previousThumbX;
                previousThumbX = event.clientX;
                
                const track = document.getElementById('scrollbar-container');
                const thumb = document.getElementById('scrollbar-thumb');
                const effectiveTrackWidth = track.offsetWidth - thumb.offsetWidth;
                
                if (effectiveTrackWidth > 0) {
                    // Calculate how much rotation one pixel of drag represents
                    const rotationPerPixel = (Math.PI * 2) / effectiveTrackWidth;
                    rotationTarget += deltaX * rotationPerPixel;
                }
            }
        }

        // CHANGED: Renamed from onPointerUp and now handles both
        function onDocumentPointerUp(event) {
            // Store state before resetting
            const wasDragging = isDragging;
            const didDrag = hasDragged;
            const wasThumbDragging = isThumbDragging;
            
            // Reset dragging state
            isDragging = false;
            isThumbDragging = false;
            hasDragged = false;
            document.getElementById('scene-container').style.cursor = 'grab';
            document.getElementById('scrollbar-thumb').style.cursor = 'grab';
            document.body.style.cursor = 'default';
            
            // Check for click if user didn't drag (handle click here for better reliability)
            if (wasDragging && !didDrag && !wasThumbDragging) {
                // This was a click, not a drag - handle it
                handleCharacterClick(event);
            }
        }

        function handleCharacterClick(event) {
            // Calculate pointer position in normalized device coordinates
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and pointer position
            raycaster.setFromCamera(pointer, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(characters);

            // Check if we clicked on a character
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                // Check if this object has userData (is a character)
                if (!clickedObject.userData || !clickedObject.userData.id) {
                    return; // Not a character
                }
                
                // Show modal for any clicked character (removed angle restriction for now)
                showModal(clickedObject.userData);
            }
        }

        function onClick(event) {
            // Fallback click handler (pointerup is primary)
            if (!hasDragged && !isDragging) {
                handleCharacterClick(event);
            }
        }

        // --- Modal Functions ---

        function showModal(data) {
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modal-content');

            // Populate modal
            document.getElementById('modal-title').textContent = data.name;
            document.getElementById('modal-region').textContent = data.region;
            document.getElementById('modal-description').textContent = data.description;
            document.getElementById('modal-image').src = data.image; // Use the same image
            
            // Populate fabrics
            const fabricsContainer = document.getElementById('modal-fabrics');
            fabricsContainer.innerHTML = ''; // Clear old ones
            data.fabrics.forEach(fabric => {
                const tag = document.createElement('span');
                tag.className = "py-2 px-4 bg-gray-100 text-gray-800 rounded-full font-medium";
                tag.textContent = fabric;
                fabricsContainer.appendChild(tag);
            });

            // Show modal
            modal.classList.add('visible');
            setTimeout(() => {
                modalContent.style.transform = 'scale(1)';
            }, 10); // Start transition
        }

        function hideModal() {
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modal-content');

            modalContent.style.transform = 'scale(0.95)';
            modal.classList.remove('visible');
        }

        // --- REMOVED: snapToClosest() function ---


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // --- 1. Handle rotation logic ---
            // Smoothly interpolate current rotation to target rotation
            rotationCurrent += (rotationTarget - rotationCurrent) * lerpFactor;
            
            cameraRig.rotation.y = rotationCurrent; // CHANGED: Rotate the camera rig
            
            // NEW: Animate background cylinder for parallax
            backgroundCylinder.rotation.y = (Math.PI / 2) + (rotationCurrent * 0.5); // Move at 50% speed

            // --- 2. Animate characters (2.5D effect) ---
            const cameraAngle = (rotationCurrent % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
            const angleStep = (Math.PI * 2) / characters.length;
            
            characters.forEach((char, i) => {
                const charAngle = (angleStep * i + Math.PI * 2) % (Math.PI * 2);
                
                // Calculate difference in angle, handling wrap-around
                let angleDiff = cameraAngle - charAngle;
                if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // Scale character based on how close it is to the center
                // `normalizedDiff` is 1 when center, 0 when far
                const focusRange = angleStep * 1.5; // How far to "feel" the focus
                const normalizedDiff = Math.max(0, 1 - Math.abs(angleDiff) / focusRange); 
                
                // Apply scale
                const scale = baseCharacterScale + (characterFocusScale - baseCharacterScale) * normalizedDiff;
                char.scale.set(scale, scale, scale);

                // REMOVED: Opacity/fade logic
            });

            // --- 3. Update Scrollbar ---
            const normalizedRotation = (rotationCurrent % (Math.PI * 2) + (Math.PI * 2)) % (Math.PI * 2);
            const scrollPercentage = normalizedRotation / (Math.PI * 2);
            
            const track = document.getElementById('scrollbar-container');
            const thumb = document.getElementById('scrollbar-thumb');
            
            if (track && thumb) {
                const effectiveTrackWidth = track.offsetWidth - thumb.offsetWidth;
                thumb.style.left = (scrollPercentage * effectiveTrackWidth) + 'px';
            }

            // --- 4. Render the scene --- (Renumbered)
            renderer.render(scene, camera);
        }

        // Start everything
        init();
    </script>
</body>
</html>